'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _child_process = require('child_process');

var _appiumUiautomator = require('appium-uiautomator');

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumBaseDriver = require('appium-base-driver');

var _asyncbox = require('asyncbox');

var _appiumSupport = require('appium-support');

var log = _appiumSupport.logger.getLogger('AndroidTestBundle');

var COMMAND_TYPES = {
    ACTION: 'action',
    SHUTDOWN: 'shutdown'
};

var TestBundle = (function () {
    function TestBundle(adb, port) {
        _classCallCheck(this, TestBundle);

        this.adb = adb;
        this.webSocket = port; //opts.webSocket
        this.systemPort = port; //opts.systemPort
        log.debug('created testbundle');
        this.logcat_proc_for_testbundle = null;
        this.onUnexpectedShutdown = new _bluebird2['default'](function () {}).cancellable();
        this.ignoreUnexpectedShutdown = false;
        this.curCommand = {};
    }

    _createClass(TestBundle, [{
        key: 'init',
        value: function init() {
            return _regeneratorRuntime.async(function init$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        this.uiAutomator2 = new _appiumUiautomator.UiAutomator_Test(this.adb);

                    case 1:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'start',
        value: function start() {
            return _regeneratorRuntime.async(function start$(context$2$0) {
                var _this = this;

                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        context$2$0.next = 2;
                        return _regeneratorRuntime.awrap(this.init());

                    case 2:
                        context$2$0.prev = 2;
                        context$2$0.next = 5;
                        return _regeneratorRuntime.awrap(this.adb.removePortForward(this.systemPort));

                    case 5:
                        context$2$0.next = 9;
                        break;

                    case 7:
                        context$2$0.prev = 7;
                        context$2$0.t0 = context$2$0['catch'](2);

                    case 9:
                        context$2$0.next = 11;
                        return _regeneratorRuntime.awrap(this.adb.forwardPort(this.systemPort, 4724));

                    case 11:
                        context$2$0.next = 13;
                        return _regeneratorRuntime.awrap(this.uiAutomator2.start());

                    case 13:
                        this.process = context$2$0.sent;

                        this.process.on('output', function (stdout, stderr) {
                            var stdoutLines = (stdout || "").split("\n");
                            var uiautoLog = /\[APPIUM-UIAUTO\](.+)\[\/APPIUM-UIAUTO\]/;
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (var _iterator = _getIterator(stdoutLines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                    var line = _step.value;

                                    if (line.trim()) {
                                        if (uiautoLog.test(line)) {
                                            log.info('[TESTBUNDLE LOG] ' + uiautoLog.exec(line)[1].trim());
                                        } else {
                                            log.debug('[UIAUTO2 STDOUT] ' + line);
                                        }
                                    }
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion && _iterator['return']) {
                                        _iterator['return']();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            var stderrLines = (stderr || "").split("\n");
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = _getIterator(stderrLines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var line = _step2.value;

                                    if (line.trim()) {
                                        log.debug('[UIAUTO2 STDERR] ' + line);
                                    }
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                                        _iterator2['return']();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        });
                        this.uiAutomator2.on(_appiumUiautomator.UiAutomator_Test.EVENT_CHANGED, function callee$2$0(msg) {
                            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                                while (1) switch (context$3$0.prev = context$3$0.next) {
                                    case 0:
                                        if (msg.state === _appiumUiautomator.UiAutomator_Test.STATE_STOPPED) {
                                            this.uiAutomator = null;
                                            log.debug("TestBundle shutdown unexpectedly");
                                            this.onUnexpectedShutdown.cancel(new Error("testbundle shut down unexpectedly"));
                                        }

                                    case 1:
                                    case 'end':
                                        return context$3$0.stop();
                                }
                            }, null, _this);
                        });
                        context$2$0.next = 18;
                        return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {
                            try {
                                _this.socketClient = _net2['default'].connect(_this.systemPort);
                                // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
                                /*                this.socketClient.on('error', (err) => {
                                                    log.debug('//////////////')
                                                    log.debug(err)
                                                    log.debug('//////////////')
                                
                                
                                                    if (!this.ignoreUnexpectedShutdown) {
                                                        //throw new Error(`Android testbundle socket crashed: ${err}`);
                                                    }
                                                });*/
                                _this.socketClient.once('connect', function () {
                                    log.info("Android testbundle socket is now connected");
                                    resolve();
                                });
                            } catch (err) {
                                reject(err);
                            }
                        }));

                    case 18:
                        return context$2$0.abrupt('return', context$2$0.sent);

                    case 19:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this, [[2, 7]]);
        }
    }, {
        key: 'exitHandler',

        // kill TestBundle
        /*        await this.adb.killProcessesByName('testbundle')
         let args = ['shell', 'am', 'instrument', '-w', '-e', 'class', 'com.boyaa.application.testbundle.TestBundle#test_RunServer',
         'com.boyaa.application.testbundle/android.test.InstrumentationTestRunner']
           log.debug("spawning: " + args.join(' '))
         this.proc = this.adb.createSubProcess(args)
           this.proc.on('exit', (code, signal) => {
         let msg = `Testbundle shutdown with code ${code}, ` + `signal ${signal}`;
         log.debug(msg);
         this.exitHandler.bind(this)
         })
         /!*        this.proc.on("error", function (err) {
         log.error("Unable to spawn adb: " + err.message);
         throw new Error("Unable to start Android Debug Bridge: " + err.message)
         }.bind(this))*!/
           await this.proc.start()
           this.proc.on('output', (stdout, stderr) => {
         log.debug(stdout)
         log.debug(stderr)
         })*/

        /*        log.debug('spawning xxxxxxxxxxxxx')
         log.debug(this.adb.getAdbPath() + this.adb.executable.defaultArgs.concat(args))
         this.proc = spawn(this.adb.getAdbPath(), this.adb.executable.defaultArgs.concat(args))
           this.proc.stdout.on('data', (data) => {
         log.debug(`stdout: ${data}`);
         });
         this.proc.stderr.on('data', (data) => {
         log.debug(`stderr: ${data}`);
         });*/

        /*        return await new Promise((resolve, reject) => {
         try {
         this.socketClient = net.connect(this.webSocket);
         // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
         this.socketClient.on('error', (err) => {
         if (!this.ignoreUnexpectedShutdown) {
         //throw new Error(`Android bootstrap socket crashed: ${err}`);
         log.debug('//////////////////////////////////')
         log.debug(err)
         log.debug('//////////////////////////////////')
         throw new Error(`Android testbundle socket crashed: ${err}`)
         }
         });
         this.socketClient.once('connect', () => {
         log.info("Android testbundle socket is now connected");
         resolve();
         });
         } catch (err) {
         reject(err);
         }
         })*/
        value: function exitHandler() {
            if (this.socketClient) {
                log.debug('ending testbundle socketClient');
                this.socketClient.end();
                this.socketClient.destroy();
                this.socketClient = null;
            }
        }
    }, {
        key: 'startLogcat',
        value: function startLogcat() {
            log.debug("Starting logcat capture for testbundle");
            var logcat_args = ["logcat", "-v", "time", "-s", "BOYAA-TESTBUNDLE"];
            var executablePath = this.adb.executable.defaultArgs.join(' ');
            this.logcat_proc_for_testbundle = (0, _child_process.spawn)(executablePath, logcat_args);
            this.logcat_proc_for_testbundle.stdout.setEncoding('utf8');
            this.logcat_proc_for_testbundle.stderr.setEncoding('utf8');

            this.logcat_proc_for_testbundle.on('error', (function (err) {
                log.error('Logcat capture failed: ' + err.message);
                if (!this.calledBack) {
                    this.calledBack = true;
                    cb(err);
                }
            }).bind(this));
            this.logcat_proc_for_testbundle.on('exit', (function (code, signal) {
                log.debug('Logcat for testbundle terminated with code ' + code + ', signal ' + signal);
                this.logcat_proc_for_testbundle = null;
            }).bind(this));
            log.debug("Redirecting logcat logs into console to make it received by appium server");
        }
    }, {
        key: 'shutdown',
        value: function shutdown() {
            return _regeneratorRuntime.async(function shutdown$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        log.debug('shutting down testbundle ...');

                        if (this.uiAutomator2) {
                            context$2$0.next = 4;
                            break;
                        }

                        log.warn("Cannot shut down Android testbundle; it has already shut down");
                        return context$2$0.abrupt('return');

                    case 4:
                        this.uiAutomator2.removeAllListeners(_appiumUiautomator.UiAutomator_Test.EVENT_CHANGED);

                        if (!this.socketClient) {
                            context$2$0.next = 8;
                            break;
                        }

                        context$2$0.next = 8;
                        return _regeneratorRuntime.awrap(this.sendCommand(COMMAND_TYPES.SHUTDOWN));

                    case 8:
                        context$2$0.next = 10;
                        return _regeneratorRuntime.awrap(this.uiAutomator2.shutdown());

                    case 10:
                        this.uiAutomator2 = null;

                        context$2$0.next = 13;
                        return _regeneratorRuntime.awrap(this.adb.removePortForward(this.systemPort));

                    case 13:
                        log.debug('shutting down testbundle ...done!');

                    case 14:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'sendAction',
        value: function sendAction(action) {
            var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var extra;
            return _regeneratorRuntime.async(function sendAction$(context$2$0) {
                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        extra = { action: action, params: params };
                        context$2$0.next = 3;
                        return _regeneratorRuntime.awrap(this.sendCommand(COMMAND_TYPES.ACTION, extra));

                    case 3:
                        return context$2$0.abrupt('return', context$2$0.sent);

                    case 4:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'sendCommand',
        value: function sendCommand(type) {
            var extra = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
            var execommand;
            return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
                var _this3 = this;

                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        if (this.socketClient) {
                            context$2$0.next = 2;
                            break;
                        }

                        throw new Error('Socket connection closed unexpectedly');

                    case 2:
                        execommand = function execommand() {
                            return _regeneratorRuntime.async(function execommand$(context$3$0) {
                                var _this2 = this;

                                while (1) switch (context$3$0.prev = context$3$0.next) {
                                    case 0:
                                        context$3$0.next = 2;
                                        return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {
                                            var cmd = _Object$assign({ cmd: type }, extra);
                                            var cmdJson = JSON.stringify(cmd) + ' \n';
                                            log.debug('Sending command to testbundle: ' + _lodash2['default'].trunc(cmdJson, 1000).trim());
                                            try {
                                                _this2.socketClient.write(cmdJson);
                                                _this2.socketClient.setEncoding('utf8');
                                            } catch (err) {
                                                _this2.socketClient.removeAllListeners('data');
                                                _this2.socketClient.removeAllListeners('timeout');
                                                _this2.socketClient = _net2['default'].connect(_this2.systemPort, function () {
                                                    log.debug('socket reconnected!');
                                                    return execommand();
                                                });
                                            }
                                            var streamData = '';
                                            _this2.socketClient.setTimeout(1000 * 60 * 2, function () {
                                                log.debug('testbundle socket timeout');
                                                _this2.socketClient.removeAllListeners('data');
                                                _this2.socketClient.removeAllListeners('timeout');
                                                resolve('');
                                            });
                                            _this2.socketClient.on('data', function (data) {
                                                log.debug("Received command result from testbundle:");
                                                try {
                                                    streamData = JSON.parse(streamData + data);
                                                    log.debug(streamData);
                                                    // we successfully parsed JSON so we've got all the data,
                                                    // remove the socket listener and evaluate
                                                    _this2.socketClient.removeAllListeners('data');
                                                    if (streamData.status === 0) {
                                                        resolve(streamData.value);
                                                    }
                                                    reject((0, _appiumBaseDriver.errorFromCode)(streamData.status));
                                                } catch (ign) {
                                                    log.debug("Stream still not complete, waiting");
                                                    streamData += data;
                                                }
                                            });
                                        }));

                                    case 2:
                                        return context$3$0.abrupt('return', context$3$0.sent);

                                    case 3:
                                    case 'end':
                                        return context$3$0.stop();
                                }
                            }, null, _this3);
                        };

                        context$2$0.next = 5;
                        return _regeneratorRuntime.awrap(execommand());

                    case 5:
                        return context$2$0.abrupt('return', context$2$0.sent);

                    case 6:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }
    }, {
        key: 'getConnection',
        value: function getConnection() {
            return _regeneratorRuntime.async(function getConnection$(context$2$0) {
                var _this4 = this;

                while (1) switch (context$2$0.prev = context$2$0.next) {
                    case 0:
                        return context$2$0.abrupt('return', new _bluebird2['default'](function (resolve, reject) {
                            _this4.socketClient = _net2['default'].connect(_this4.webSocket, function () {
                                log.debug('testbundle socket reconnected!!!');
                                resolve(this.socketClient);
                            });
                        }));

                    case 1:
                    case 'end':
                        return context$2$0.stop();
                }
            }, null, this);
        }

        /*async sendCommand(type, extra = {}) {
         /!*        if (!this.socketClient) {
         log.debug('==========socket closed========')
         throw new Error('Socket connection closed unexpectedly');
         }*!/
         return await new B((resolve, reject) => {
         let cmd = Object.assign({cmd: type}, extra);
         let cmdJson = `${JSON.stringify(cmd)}\n`;
         log.debug(`Sending command to android testbundle: ${_.trunc(cmdJson, 1000).trim()}`);
           let exeFunc = async () => {
         try {
           if (this.socketClient) {
         this.socketClient.write(cmdJson);
         this.socketClient.setEncoding('utf8');
         this.socketClient('data', (data) => {
         try {
         streamData = JSON.parse(streamData + data);
         // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         this.socketClient.removeAllListeners('data');
         if (streamData.status === 0) {
         resolve(streamData.value);
         }
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })
         }
           else {
         let client = new net.Socket();
         let streamData = '';
         client.connect(this.webSocket, '127.0.0.1', function() {
         log.debug('testbundle socket reconnected!')
         log.debug('send stream')
         client.write(cmdJson);
         log.debug('send end')
         client.setEncoding('utf8');
        
         })
         client.removeAllListeners('data');
         client.on('data', (data) => {
         try {
         log.debug("data:" + data.toString())
         streamData = JSON.parse(streamData + data);
           log.debug("streamdata: " + streamData)
           // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         if (streamData.status === 0) {
         resolve(streamData.value);
         client.removeAllListeners('data');
         client.close()
           }
           reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })
         }
             /!*                    this.socketClient.write(cmdJson);
         this.socketClient.setEncoding('utf8');
         let streamData = '';
         this.socketClient.on('data', (data) => {
         try {
         streamData = JSON.parse(streamData + data);
         // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         this.socketClient.removeAllListeners('data');
         if (streamData.status === 0) {
         resolve(streamData.value);
         }
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })*!/
           } catch (e) {
         throw new Error('Error sending command to testbundle' + e)
         }
         }
         //retry(2, exeFunc);
         exeFunc()
           /!*this.socketClient.write(cmdJson);
         this.socketClient.setEncoding('utf8');
         let streamData = '';
         this.socketClient.on('data', (data) => {
         try {
         streamData = JSON.parse(streamData + data);
         // we successfully parsed JSON so we've got all the data,
         // remove the socket listener and evaluate
         this.socketClient.removeAllListeners('data');
         if (streamData.status === 0) {
         resolve(streamData.value);
         }
         log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
         reject(errorFromCode(streamData.status));
         } catch (ign) {
         log.debug("Stream still not complete, waiting");
         streamData += data;
         }
         })*!/
           })
           }*/
    }]);

    return TestBundle;
})();

exports['default'] = TestBundle;
module.exports = exports['default'];

// log.debug(err)
//# sourceMappingURL=data:application/json;charset=utf8;base64,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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQXpQQyxVQUFVOzs7cUJBeVhELFVBQVUiLCJmaWxlIjoibGliL3Rlc3RidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3NwYXdufSBmcm9tICdjaGlsZF9wcm9jZXNzJ1xyXG5cclxuXHJcbmltcG9ydCB7VWlBdXRvbWF0b3JfVGVzdH0gZnJvbSAnYXBwaXVtLXVpYXV0b21hdG9yJ1xyXG5cclxuaW1wb3J0IG5ldCBmcm9tICduZXQnO1xyXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XHJcbmltcG9ydCB7ZXJyb3JGcm9tQ29kZX0gZnJvbSAnYXBwaXVtLWJhc2UtZHJpdmVyJztcclxuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XHJcblxyXG5cclxuY29uc3QgbG9nID0gbG9nZ2VyLmdldExvZ2dlcignQW5kcm9pZFRlc3RCdW5kbGUnKTtcclxuXHJcbmNvbnN0IENPTU1BTkRfVFlQRVMgPSB7XHJcbiAgICBBQ1RJT046ICdhY3Rpb24nLFxyXG4gICAgU0hVVERPV046ICdzaHV0ZG93bidcclxufTtcclxuXHJcbmNsYXNzIFRlc3RCdW5kbGUge1xyXG4gICAgY29uc3RydWN0b3IoYWRiLCBwb3J0KSB7XHJcbiAgICAgICAgdGhpcy5hZGIgPSBhZGJcclxuICAgICAgICB0aGlzLndlYlNvY2tldCA9IHBvcnQgLy9vcHRzLndlYlNvY2tldFxyXG4gICAgICAgIHRoaXMuc3lzdGVtUG9ydCA9IHBvcnQgLy9vcHRzLnN5c3RlbVBvcnRcclxuICAgICAgICBsb2cuZGVidWcoJ2NyZWF0ZWQgdGVzdGJ1bmRsZScpXHJcbiAgICAgICAgdGhpcy5sb2djYXRfcHJvY19mb3JfdGVzdGJ1bmRsZSA9IG51bGxcclxuICAgICAgICB0aGlzLm9uVW5leHBlY3RlZFNodXRkb3duID0gbmV3IEIoKCkgPT4ge30pLmNhbmNlbGxhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVVbmV4cGVjdGVkU2h1dGRvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1ckNvbW1hbmQgPSB7fVxyXG4gICAgfVxyXG4gICAgYXN5bmMgaW5pdCAoKSB7XHJcbiAgICAgICAgdGhpcy51aUF1dG9tYXRvcjIgPSBuZXcgVWlBdXRvbWF0b3JfVGVzdCh0aGlzLmFkYik7XHJcbiAgICB9XHJcbiAgICBhc3luYyBzdGFydCgpIHtcclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0KCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGIucmVtb3ZlUG9ydEZvcndhcmQodGhpcy5zeXN0ZW1Qb3J0KVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgIC8vIGxvZy5kZWJ1ZyhlcnIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLmFkYi5mb3J3YXJkUG9ydCh0aGlzLnN5c3RlbVBvcnQsIDQ3MjQpO1xyXG5cclxuICAgICAgICB0aGlzLnByb2Nlc3MgPSBhd2FpdCB0aGlzLnVpQXV0b21hdG9yMi5zdGFydCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucHJvY2Vzcy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzdGRvdXRMaW5lcyA9IChzdGRvdXQgfHwgXCJcIikuc3BsaXQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHVpYXV0b0xvZyA9IC9cXFtBUFBJVU0tVUlBVVRPXFxdKC4rKVxcW1xcL0FQUElVTS1VSUFVVE9cXF0vO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dExpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodWlhdXRvTG9nLnRlc3QobGluZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oYFtURVNUQlVORExFIExPR10gJHt1aWF1dG9Mb2cuZXhlYyhsaW5lKVsxXS50cmltKCl9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBbVUlBVVRPMiBTVERPVVRdICR7bGluZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHN0ZGVyckxpbmVzID0gKHN0ZGVyciB8fCBcIlwiKS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiBzdGRlcnJMaW5lcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBbVUlBVVRPMiBTVERFUlJdICR7bGluZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudWlBdXRvbWF0b3IyLm9uKFVpQXV0b21hdG9yX1Rlc3QuRVZFTlRfQ0hBTkdFRCwgYXN5bmMgKG1zZykgPT4ge1xyXG4gICAgICAgICAgICBpZiAobXNnLnN0YXRlID09PSBVaUF1dG9tYXRvcl9UZXN0LlNUQVRFX1NUT1BQRUQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlBdXRvbWF0b3IgPSBudWxsO1xyXG5cdFx0bG9nLmRlYnVnKFwiVGVzdEJ1bmRsZSBzaHV0ZG93biB1bmV4cGVjdGVkbHlcIilcclxuICAgICAgICAgICAgICAgIHRoaXMub25VbmV4cGVjdGVkU2h1dGRvd24uY2FuY2VsKG5ldyBFcnJvcihcInRlc3RidW5kbGUgc2h1dCBkb3duIHVuZXhwZWN0ZWRseVwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50ID0gbmV0LmNvbm5lY3QodGhpcy5zeXN0ZW1Qb3J0KTtcclxuICAgICAgICAgICAgICAgIC8vIFdpbmRvd3M6IHRoZSBzb2NrZXQgZXJyb3JzIG91dCB3aGVuIEFEQiByZXN0YXJ0cy4gTGV0J3MgY2F0Y2ggaXQgdG8gYXZvaWQgY3Jhc2hpbmcuXHJcbi8qICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJy8vLy8vLy8vLy8vLy8vJylcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygnLy8vLy8vLy8vLy8vLy8nKVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlnbm9yZVVuZXhwZWN0ZWRTaHV0ZG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihgQW5kcm9pZCB0ZXN0YnVuZGxlIHNvY2tldCBjcmFzaGVkOiAke2Vycn1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTsqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQub25jZSgnY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIkFuZHJvaWQgdGVzdGJ1bmRsZSBzb2NrZXQgaXMgbm93IGNvbm5lY3RlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8ga2lsbCBUZXN0QnVuZGxlXHJcbiAgICAgICAgLyogICAgICAgIGF3YWl0IHRoaXMuYWRiLmtpbGxQcm9jZXNzZXNCeU5hbWUoJ3Rlc3RidW5kbGUnKVxyXG4gICAgICAgICBsZXQgYXJncyA9IFsnc2hlbGwnLCAnYW0nLCAnaW5zdHJ1bWVudCcsICctdycsICctZScsICdjbGFzcycsICdjb20uYm95YWEuYXBwbGljYXRpb24udGVzdGJ1bmRsZS5UZXN0QnVuZGxlI3Rlc3RfUnVuU2VydmVyJyxcclxuICAgICAgICAgJ2NvbS5ib3lhYS5hcHBsaWNhdGlvbi50ZXN0YnVuZGxlL2FuZHJvaWQudGVzdC5JbnN0cnVtZW50YXRpb25UZXN0UnVubmVyJ11cclxuXHJcbiAgICAgICAgIGxvZy5kZWJ1ZyhcInNwYXduaW5nOiBcIiArIGFyZ3Muam9pbignICcpKVxyXG4gICAgICAgICB0aGlzLnByb2MgPSB0aGlzLmFkYi5jcmVhdGVTdWJQcm9jZXNzKGFyZ3MpXHJcblxyXG4gICAgICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XHJcbiAgICAgICAgIGxldCBtc2cgPSBgVGVzdGJ1bmRsZSBzaHV0ZG93biB3aXRoIGNvZGUgJHtjb2RlfSwgYCArIGBzaWduYWwgJHtzaWduYWx9YDtcclxuICAgICAgICAgbG9nLmRlYnVnKG1zZyk7XHJcbiAgICAgICAgIHRoaXMuZXhpdEhhbmRsZXIuYmluZCh0aGlzKVxyXG4gICAgICAgICB9KVxyXG4gICAgICAgICAvISogICAgICAgIHRoaXMucHJvYy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgbG9nLmVycm9yKFwiVW5hYmxlIHRvIHNwYXduIGFkYjogXCIgKyBlcnIubWVzc2FnZSk7XHJcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzdGFydCBBbmRyb2lkIERlYnVnIEJyaWRnZTogXCIgKyBlcnIubWVzc2FnZSlcclxuICAgICAgICAgfS5iaW5kKHRoaXMpKSohL1xyXG5cclxuICAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0YXJ0KClcclxuXHJcbiAgICAgICAgIHRoaXMucHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XHJcbiAgICAgICAgIGxvZy5kZWJ1ZyhzdGRvdXQpXHJcbiAgICAgICAgIGxvZy5kZWJ1ZyhzdGRlcnIpXHJcbiAgICAgICAgIH0pKi9cclxuXHJcbiAgICAgICAgLyogICAgICAgIGxvZy5kZWJ1Zygnc3Bhd25pbmcgeHh4eHh4eHh4eHh4eCcpXHJcbiAgICAgICAgIGxvZy5kZWJ1Zyh0aGlzLmFkYi5nZXRBZGJQYXRoKCkgKyB0aGlzLmFkYi5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChhcmdzKSlcclxuICAgICAgICAgdGhpcy5wcm9jID0gc3Bhd24odGhpcy5hZGIuZ2V0QWRiUGF0aCgpLCB0aGlzLmFkYi5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChhcmdzKSlcclxuXHJcbiAgICAgICAgIHRoaXMucHJvYy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICBsb2cuZGVidWcoYHN0ZG91dDogJHtkYXRhfWApO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgICAgdGhpcy5wcm9jLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XHJcbiAgICAgICAgIGxvZy5kZWJ1Zyhgc3RkZXJyOiAke2RhdGF9YCk7XHJcbiAgICAgICAgIH0pOyovXHJcblxyXG4gICAgICAgIC8qICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICB0cnkge1xyXG4gICAgICAgICB0aGlzLnNvY2tldENsaWVudCA9IG5ldC5jb25uZWN0KHRoaXMud2ViU29ja2V0KTtcclxuICAgICAgICAgLy8gV2luZG93czogdGhlIHNvY2tldCBlcnJvcnMgb3V0IHdoZW4gQURCIHJlc3RhcnRzLiBMZXQncyBjYXRjaCBpdCB0byBhdm9pZCBjcmFzaGluZy5cclxuICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQub24oJ2Vycm9yJywgKGVycikgPT4ge1xyXG4gICAgICAgICBpZiAoIXRoaXMuaWdub3JlVW5leHBlY3RlZFNodXRkb3duKSB7XHJcbiAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKGBBbmRyb2lkIGJvb3RzdHJhcCBzb2NrZXQgY3Jhc2hlZDogJHtlcnJ9YCk7XHJcbiAgICAgICAgIGxvZy5kZWJ1ZygnLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLycpXHJcbiAgICAgICAgIGxvZy5kZWJ1ZyhlcnIpXHJcbiAgICAgICAgIGxvZy5kZWJ1ZygnLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLycpXHJcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW5kcm9pZCB0ZXN0YnVuZGxlIHNvY2tldCBjcmFzaGVkOiAke2Vycn1gKVxyXG4gICAgICAgICB9XHJcbiAgICAgICAgIH0pO1xyXG4gICAgICAgICB0aGlzLnNvY2tldENsaWVudC5vbmNlKCdjb25uZWN0JywgKCkgPT4ge1xyXG4gICAgICAgICBsb2cuaW5mbyhcIkFuZHJvaWQgdGVzdGJ1bmRsZSBzb2NrZXQgaXMgbm93IGNvbm5lY3RlZFwiKTtcclxuICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICB9KTtcclxuICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICB9XHJcbiAgICAgICAgIH0pKi9cclxuICAgIH1cclxuXHJcbiAgICBleGl0SGFuZGxlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5zb2NrZXRDbGllbnQpIHtcclxuICAgICAgICAgICAgbG9nLmRlYnVnKCdlbmRpbmcgdGVzdGJ1bmRsZSBzb2NrZXRDbGllbnQnKVxyXG4gICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5lbmQoKVxyXG4gICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5kZXN0cm95KClcclxuICAgICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQgPSBudWxsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0TG9nY2F0KCkge1xyXG4gICAgICAgIGxvZy5kZWJ1ZyhcIlN0YXJ0aW5nIGxvZ2NhdCBjYXB0dXJlIGZvciB0ZXN0YnVuZGxlXCIpXHJcbiAgICAgICAgbGV0IGxvZ2NhdF9hcmdzID0gW1wibG9nY2F0XCIsIFwiLXZcIiwgXCJ0aW1lXCIsIFwiLXNcIiwgXCJCT1lBQS1URVNUQlVORExFXCJdXHJcbiAgICAgICAgbGV0IGV4ZWN1dGFibGVQYXRoID0gdGhpcy5hZGIuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5qb2luKCcgJylcclxuICAgICAgICB0aGlzLmxvZ2NhdF9wcm9jX2Zvcl90ZXN0YnVuZGxlID0gc3Bhd24oZXhlY3V0YWJsZVBhdGgsIGxvZ2NhdF9hcmdzKVxyXG4gICAgICAgIHRoaXMubG9nY2F0X3Byb2NfZm9yX3Rlc3RidW5kbGUuc3Rkb3V0LnNldEVuY29kaW5nKCd1dGY4JylcclxuICAgICAgICB0aGlzLmxvZ2NhdF9wcm9jX2Zvcl90ZXN0YnVuZGxlLnN0ZGVyci5zZXRFbmNvZGluZygndXRmOCcpXHJcblxyXG4gICAgICAgIHRoaXMubG9nY2F0X3Byb2NfZm9yX3Rlc3RidW5kbGUub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBsb2cuZXJyb3IoJ0xvZ2NhdCBjYXB0dXJlIGZhaWxlZDogJyArIGVyci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxlZEJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkQmFjayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLmxvZ2NhdF9wcm9jX2Zvcl90ZXN0YnVuZGxlLm9uKCdleGl0JywgZnVuY3Rpb24gKGNvZGUsIHNpZ25hbCkge1xyXG4gICAgICAgICAgICBsb2cuZGVidWcoJ0xvZ2NhdCBmb3IgdGVzdGJ1bmRsZSB0ZXJtaW5hdGVkIHdpdGggY29kZSAnICsgY29kZSArICcsIHNpZ25hbCAnICsgc2lnbmFsKTtcclxuICAgICAgICAgICAgdGhpcy5sb2djYXRfcHJvY19mb3JfdGVzdGJ1bmRsZSA9IG51bGw7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBsb2cuZGVidWcoXCJSZWRpcmVjdGluZyBsb2djYXQgbG9ncyBpbnRvIGNvbnNvbGUgdG8gbWFrZSBpdCByZWNlaXZlZCBieSBhcHBpdW0gc2VydmVyXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNodXRkb3duKCkge1xyXG4gICAgICAgIGxvZy5kZWJ1Zygnc2h1dHRpbmcgZG93biB0ZXN0YnVuZGxlIC4uLicpXHJcbiAgICAgICAgaWYgKCF0aGlzLnVpQXV0b21hdG9yMikge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIkNhbm5vdCBzaHV0IGRvd24gQW5kcm9pZCB0ZXN0YnVuZGxlOyBpdCBoYXMgYWxyZWFkeSBzaHV0IGRvd25cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51aUF1dG9tYXRvcjIucmVtb3ZlQWxsTGlzdGVuZXJzKFVpQXV0b21hdG9yX1Rlc3QuRVZFTlRfQ0hBTkdFRCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Q2xpZW50KSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZENvbW1hbmQoQ09NTUFORF9UWVBFUy5TSFVURE9XTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMudWlBdXRvbWF0b3IyLnNodXRkb3duKCk7XHJcbiAgICAgICAgdGhpcy51aUF1dG9tYXRvcjIgPSBudWxsO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLmFkYi5yZW1vdmVQb3J0Rm9yd2FyZCh0aGlzLnN5c3RlbVBvcnQpXHJcbiAgICAgICAgbG9nLmRlYnVnKCdzaHV0dGluZyBkb3duIHRlc3RidW5kbGUgLi4uZG9uZSEnKVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNlbmRBY3Rpb24oYWN0aW9uLCBwYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIGxldCBleHRyYSA9IHthY3Rpb24sIHBhcmFtc307XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZENvbW1hbmQoQ09NTUFORF9UWVBFUy5BQ1RJT04sIGV4dHJhKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBzZW5kQ29tbWFuZCAodHlwZSwgZXh0cmEgPSB7fSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zb2NrZXRDbGllbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZXhlY29tbWFuZCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY21kID0gT2JqZWN0LmFzc2lnbih7Y21kOiB0eXBlfSwgZXh0cmEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNtZEpzb24gPSBgJHtKU09OLnN0cmluZ2lmeShjbWQpfSBcXG5gO1xyXG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKGBTZW5kaW5nIGNvbW1hbmQgdG8gdGVzdGJ1bmRsZTogJHtfLnRydW5jKGNtZEpzb24sIDEwMDApLnRyaW0oKX1gKTtcclxuICAgICAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC53cml0ZShjbWRKc29uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuXHRcdCAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudCA9IG5ldC5jb25uZWN0KHRoaXMuc3lzdGVtUG9ydCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zygnc29ja2V0IHJlY29ubmVjdGVkIScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjb21tYW5kKClcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBzdHJlYW1EYXRhID0gJyc7XHJcblx0XHR0aGlzLnNvY2tldENsaWVudC5zZXRUaW1lb3V0KDEwMDAgKiA2MCAqIDIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoJ3Rlc3RidW5kbGUgc29ja2V0IHRpbWVvdXQnKVxyXG5cdFx0ICAgIHRoaXMuc29ja2V0Q2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygndGltZW91dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJycpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDbGllbnQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlJlY2VpdmVkIGNvbW1hbmQgcmVzdWx0IGZyb20gdGVzdGJ1bmRsZTpcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtRGF0YSA9IEpTT04ucGFyc2Uoc3RyZWFtRGF0YSArIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoc3RyZWFtRGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHBhcnNlZCBKU09OIHNvIHdlJ3ZlIGdvdCBhbGwgdGhlIGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc29ja2V0IGxpc3RlbmVyIGFuZCBldmFsdWF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbURhdGEuc3RhdHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0cmVhbURhdGEudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvckZyb21Db2RlKHN0cmVhbURhdGEuc3RhdHVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWduKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlN0cmVhbSBzdGlsbCBub3QgY29tcGxldGUsIHdhaXRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbURhdGEgKz0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhd2FpdCBleGVjb21tYW5kKClcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBnZXRDb25uZWN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Q2xpZW50ID0gbmV0LmNvbm5lY3QodGhpcy53ZWJTb2NrZXQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZygndGVzdGJ1bmRsZSBzb2NrZXQgcmVjb25uZWN0ZWQhISEnKVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNvY2tldENsaWVudClcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIC8qYXN5bmMgc2VuZENvbW1hbmQodHlwZSwgZXh0cmEgPSB7fSkge1xyXG4gICAgIC8hKiAgICAgICAgaWYgKCF0aGlzLnNvY2tldENsaWVudCkge1xyXG4gICAgIGxvZy5kZWJ1ZygnPT09PT09PT09PXNvY2tldCBjbG9zZWQ9PT09PT09PScpXHJcbiAgICAgdGhyb3cgbmV3IEVycm9yKCdTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQgdW5leHBlY3RlZGx5Jyk7XHJcbiAgICAgfSohL1xyXG4gICAgIHJldHVybiBhd2FpdCBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgbGV0IGNtZCA9IE9iamVjdC5hc3NpZ24oe2NtZDogdHlwZX0sIGV4dHJhKTtcclxuICAgICBsZXQgY21kSnNvbiA9IGAke0pTT04uc3RyaW5naWZ5KGNtZCl9XFxuYDtcclxuICAgICBsb2cuZGVidWcoYFNlbmRpbmcgY29tbWFuZCB0byBhbmRyb2lkIHRlc3RidW5kbGU6ICR7Xy50cnVuYyhjbWRKc29uLCAxMDAwKS50cmltKCl9YCk7XHJcblxyXG4gICAgIGxldCBleGVGdW5jID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgIHRyeSB7XHJcblxyXG4gICAgIGlmICh0aGlzLnNvY2tldENsaWVudCkge1xyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50LndyaXRlKGNtZEpzb24pO1xyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50LnNldEVuY29kaW5nKCd1dGY4Jyk7XHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQoJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgIHRyeSB7XHJcbiAgICAgc3RyZWFtRGF0YSA9IEpTT04ucGFyc2Uoc3RyZWFtRGF0YSArIGRhdGEpO1xyXG4gICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgSlNPTiBzbyB3ZSd2ZSBnb3QgYWxsIHRoZSBkYXRhLFxyXG4gICAgIC8vIHJlbW92ZSB0aGUgc29ja2V0IGxpc3RlbmVyIGFuZCBldmFsdWF0ZVxyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xyXG4gICAgIGlmIChzdHJlYW1EYXRhLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgIHJlc29sdmUoc3RyZWFtRGF0YS52YWx1ZSk7XHJcbiAgICAgfVxyXG4gICAgIGxvZy5kZWJ1ZyhcIlJlY2VpdmVkIGNvbW1hbmQgcmVzdWx0IGZyb20gdGVzdGJ1bmRsZTpcIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbURhdGEpKTtcclxuICAgICByZWplY3QoZXJyb3JGcm9tQ29kZShzdHJlYW1EYXRhLnN0YXR1cykpO1xyXG4gICAgIH0gY2F0Y2ggKGlnbikge1xyXG4gICAgIGxvZy5kZWJ1ZyhcIlN0cmVhbSBzdGlsbCBub3QgY29tcGxldGUsIHdhaXRpbmdcIik7XHJcbiAgICAgc3RyZWFtRGF0YSArPSBkYXRhO1xyXG4gICAgIH1cclxuICAgICB9KVxyXG4gICAgIH1cclxuXHJcbiAgICAgZWxzZSB7XHJcbiAgICAgbGV0IGNsaWVudCA9IG5ldyBuZXQuU29ja2V0KCk7XHJcbiAgICAgbGV0IHN0cmVhbURhdGEgPSAnJztcclxuICAgICBjbGllbnQuY29ubmVjdCh0aGlzLndlYlNvY2tldCwgJzEyNy4wLjAuMScsIGZ1bmN0aW9uKCkge1xyXG4gICAgIGxvZy5kZWJ1ZygndGVzdGJ1bmRsZSBzb2NrZXQgcmVjb25uZWN0ZWQhJylcclxuICAgICBsb2cuZGVidWcoJ3NlbmQgc3RyZWFtJylcclxuICAgICBjbGllbnQud3JpdGUoY21kSnNvbik7XHJcbiAgICAgbG9nLmRlYnVnKCdzZW5kIGVuZCcpXHJcbiAgICAgY2xpZW50LnNldEVuY29kaW5nKCd1dGY4Jyk7XHJcblxyXG5cclxuXHJcbiAgICAgfSlcclxuICAgICBjbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XHJcbiAgICAgY2xpZW50Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICB0cnkge1xyXG4gICAgIGxvZy5kZWJ1ZyhcImRhdGE6XCIgKyBkYXRhLnRvU3RyaW5nKCkpXHJcbiAgICAgc3RyZWFtRGF0YSA9IEpTT04ucGFyc2Uoc3RyZWFtRGF0YSArIGRhdGEpO1xyXG5cclxuICAgICBsb2cuZGVidWcoXCJzdHJlYW1kYXRhOiBcIiArIHN0cmVhbURhdGEpXHJcblxyXG4gICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgSlNPTiBzbyB3ZSd2ZSBnb3QgYWxsIHRoZSBkYXRhLFxyXG4gICAgIC8vIHJlbW92ZSB0aGUgc29ja2V0IGxpc3RlbmVyIGFuZCBldmFsdWF0ZVxyXG4gICAgIGxvZy5kZWJ1ZyhcIlJlY2VpdmVkIGNvbW1hbmQgcmVzdWx0IGZyb20gdGVzdGJ1bmRsZTpcIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbURhdGEpKTtcclxuICAgICBpZiAoc3RyZWFtRGF0YS5zdGF0dXMgPT09IDApIHtcclxuICAgICByZXNvbHZlKHN0cmVhbURhdGEudmFsdWUpO1xyXG4gICAgIGNsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICBjbGllbnQuY2xvc2UoKVxyXG5cclxuICAgICB9XHJcblxyXG4gICAgIHJlamVjdChlcnJvckZyb21Db2RlKHN0cmVhbURhdGEuc3RhdHVzKSk7XHJcbiAgICAgfSBjYXRjaCAoaWduKSB7XHJcbiAgICAgbG9nLmRlYnVnKFwiU3RyZWFtIHN0aWxsIG5vdCBjb21wbGV0ZSwgd2FpdGluZ1wiKTtcclxuICAgICBzdHJlYW1EYXRhICs9IGRhdGE7XHJcbiAgICAgfVxyXG4gICAgIH0pXHJcbiAgICAgfVxyXG5cclxuXHJcbiAgICAgLyEqICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENsaWVudC53cml0ZShjbWRKc29uKTtcclxuICAgICB0aGlzLnNvY2tldENsaWVudC5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgIGxldCBzdHJlYW1EYXRhID0gJyc7XHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xyXG4gICAgIHRyeSB7XHJcbiAgICAgc3RyZWFtRGF0YSA9IEpTT04ucGFyc2Uoc3RyZWFtRGF0YSArIGRhdGEpO1xyXG4gICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgSlNPTiBzbyB3ZSd2ZSBnb3QgYWxsIHRoZSBkYXRhLFxyXG4gICAgIC8vIHJlbW92ZSB0aGUgc29ja2V0IGxpc3RlbmVyIGFuZCBldmFsdWF0ZVxyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xyXG4gICAgIGlmIChzdHJlYW1EYXRhLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgIHJlc29sdmUoc3RyZWFtRGF0YS52YWx1ZSk7XHJcbiAgICAgfVxyXG4gICAgIGxvZy5kZWJ1ZyhcIlJlY2VpdmVkIGNvbW1hbmQgcmVzdWx0IGZyb20gdGVzdGJ1bmRsZTpcIiArIEpTT04uc3RyaW5naWZ5KHN0cmVhbURhdGEpKTtcclxuICAgICByZWplY3QoZXJyb3JGcm9tQ29kZShzdHJlYW1EYXRhLnN0YXR1cykpO1xyXG4gICAgIH0gY2F0Y2ggKGlnbikge1xyXG4gICAgIGxvZy5kZWJ1ZyhcIlN0cmVhbSBzdGlsbCBub3QgY29tcGxldGUsIHdhaXRpbmdcIik7XHJcbiAgICAgc3RyZWFtRGF0YSArPSBkYXRhO1xyXG4gICAgIH1cclxuICAgICB9KSohL1xyXG5cclxuICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBzZW5kaW5nIGNvbW1hbmQgdG8gdGVzdGJ1bmRsZScgKyBlKVxyXG4gICAgIH1cclxuICAgICB9XHJcbiAgICAgLy9yZXRyeSgyLCBleGVGdW5jKTtcclxuICAgICBleGVGdW5jKClcclxuXHJcbiAgICAgLyEqdGhpcy5zb2NrZXRDbGllbnQud3JpdGUoY21kSnNvbik7XHJcbiAgICAgdGhpcy5zb2NrZXRDbGllbnQuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcclxuICAgICBsZXQgc3RyZWFtRGF0YSA9ICcnO1xyXG4gICAgIHRoaXMuc29ja2V0Q2xpZW50Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcclxuICAgICB0cnkge1xyXG4gICAgIHN0cmVhbURhdGEgPSBKU09OLnBhcnNlKHN0cmVhbURhdGEgKyBkYXRhKTtcclxuICAgICAvLyB3ZSBzdWNjZXNzZnVsbHkgcGFyc2VkIEpTT04gc28gd2UndmUgZ290IGFsbCB0aGUgZGF0YSxcclxuICAgICAvLyByZW1vdmUgdGhlIHNvY2tldCBsaXN0ZW5lciBhbmQgZXZhbHVhdGVcclxuICAgICB0aGlzLnNvY2tldENsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcclxuICAgICBpZiAoc3RyZWFtRGF0YS5zdGF0dXMgPT09IDApIHtcclxuICAgICByZXNvbHZlKHN0cmVhbURhdGEudmFsdWUpO1xyXG4gICAgIH1cclxuICAgICBsb2cuZGVidWcoXCJSZWNlaXZlZCBjb21tYW5kIHJlc3VsdCBmcm9tIHRlc3RidW5kbGU6XCIgKyBKU09OLnN0cmluZ2lmeShzdHJlYW1EYXRhKSk7XHJcbiAgICAgcmVqZWN0KGVycm9yRnJvbUNvZGUoc3RyZWFtRGF0YS5zdGF0dXMpKTtcclxuICAgICB9IGNhdGNoIChpZ24pIHtcclxuICAgICBsb2cuZGVidWcoXCJTdHJlYW0gc3RpbGwgbm90IGNvbXBsZXRlLCB3YWl0aW5nXCIpO1xyXG4gICAgIHN0cmVhbURhdGEgKz0gZGF0YTtcclxuICAgICB9XHJcbiAgICAgfSkqIS9cclxuXHJcbiAgICAgfSlcclxuXHJcbiAgICAgfSovXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRlc3RCdW5kbGVcclxuIl0sInNvdXJjZVJvb3QiOiIuLi8uLiJ9
