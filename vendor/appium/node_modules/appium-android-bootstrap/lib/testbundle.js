import {spawn} from 'child_process'


import {UiAutomator_Test} from 'appium-uiautomator'

import net from 'net';
import _ from 'lodash';
import B from 'bluebird';
import {errorFromCode} from 'appium-base-driver';
import { sleep, retry, retryInterval } from 'asyncbox';
import { logger } from 'appium-support';


const log = logger.getLogger('AndroidTestBundle');

const COMMAND_TYPES = {
    ACTION: 'action',
    SHUTDOWN: 'shutdown'
};

class TestBundle {
    constructor(adb, port) {
        this.adb = adb
        this.webSocket = port //opts.webSocket
        this.systemPort = port //opts.systemPort
        log.debug('created testbundle')
        this.logcat_proc_for_testbundle = null
        this.onUnexpectedShutdown = new B(() => {}).cancellable();
        this.ignoreUnexpectedShutdown = false;
        this.curCommand = {}
    }
    async init () {
        this.uiAutomator2 = new UiAutomator_Test(this.adb);
    }
    async start() {

        await this.init();
        try {
            await this.adb.removePortForward(this.systemPort)
        } catch (err) {
           // log.debug(err)
        }

        await this.adb.forwardPort(this.systemPort, 4724);

        this.process = await this.uiAutomator2.start();
        
        this.process.on('output', (stdout, stderr) => {
            let stdoutLines = (stdout || "").split("\n");
            const uiautoLog = /\[APPIUM-UIAUTO\](.+)\[\/APPIUM-UIAUTO\]/;
            for (let line of stdoutLines) {
                if (line.trim()) {
                    if (uiautoLog.test(line)) {
                        log.info(`[TESTBUNDLE LOG] ${uiautoLog.exec(line)[1].trim()}`);
                    } else {
                        log.debug(`[UIAUTO2 STDOUT] ${line}`);
                    }
                }
            }
            let stderrLines = (stderr || "").split("\n");
            for (let line of stderrLines) {
                if (line.trim()) {
                    log.debug(`[UIAUTO2 STDERR] ${line}`);
                }
            }
        });
        this.uiAutomator2.on(UiAutomator_Test.EVENT_CHANGED, async (msg) => {
            if (msg.state === UiAutomator_Test.STATE_STOPPED) {
                this.uiAutomator = null;
		log.debug("TestBundle shutdown unexpectedly")
                this.onUnexpectedShutdown.cancel(new Error("testbundle shut down unexpectedly"));
            }
        });
        return await new Promise ((resolve, reject) => {
            try {
                this.socketClient = net.connect(this.systemPort);
                // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
/*                this.socketClient.on('error', (err) => {
                    log.debug('//////////////')
                    log.debug(err)
                    log.debug('//////////////')


                    if (!this.ignoreUnexpectedShutdown) {
                        //throw new Error(`Android testbundle socket crashed: ${err}`);
                    }
                });*/
                this.socketClient.once('connect', () => {
                    log.info("Android testbundle socket is now connected");
                    resolve();
                });
            } catch (err) {
                reject(err);
            }
        });


        // kill TestBundle
        /*        await this.adb.killProcessesByName('testbundle')
         let args = ['shell', 'am', 'instrument', '-w', '-e', 'class', 'com.boyaa.application.testbundle.TestBundle#test_RunServer',
         'com.boyaa.application.testbundle/android.test.InstrumentationTestRunner']

         log.debug("spawning: " + args.join(' '))
         this.proc = this.adb.createSubProcess(args)

         this.proc.on('exit', (code, signal) => {
         let msg = `Testbundle shutdown with code ${code}, ` + `signal ${signal}`;
         log.debug(msg);
         this.exitHandler.bind(this)
         })
         /!*        this.proc.on("error", function (err) {
         log.error("Unable to spawn adb: " + err.message);
         throw new Error("Unable to start Android Debug Bridge: " + err.message)
         }.bind(this))*!/

         await this.proc.start()

         this.proc.on('output', (stdout, stderr) => {
         log.debug(stdout)
         log.debug(stderr)
         })*/

        /*        log.debug('spawning xxxxxxxxxxxxx')
         log.debug(this.adb.getAdbPath() + this.adb.executable.defaultArgs.concat(args))
         this.proc = spawn(this.adb.getAdbPath(), this.adb.executable.defaultArgs.concat(args))

         this.proc.stdout.on('data', (data) => {
         log.debug(`stdout: ${data}`);
         });
         this.proc.stderr.on('data', (data) => {
         log.debug(`stderr: ${data}`);
         });*/

        /*        return await new Promise((resolve, reject) => {
         try {
         this.socketClient = net.connect(this.webSocket);
         // Windows: the socket errors out when ADB restarts. Let's catch it to avoid crashing.
         this.socketClient.on('error', (err) => {
         if (!this.ignoreUnexpectedShutdown) {
         //throw new Error(`Android bootstrap socket crashed: ${err}`);
         log.debug('//////////////////////////////////')
         log.debug(err)
         log.debug('//////////////////////////////////')
         throw new Error(`Android testbundle socket crashed: ${err}`)
         }
         });
         this.socketClient.once('connect', () => {
         log.info("Android testbundle socket is now connected");
         resolve();
         });
         } catch (err) {
         reject(err);
         }
         })*/
    }

    exitHandler() {
        if (this.socketClient) {
            log.debug('ending testbundle socketClient')
            this.socketClient.end()
            this.socketClient.destroy()
            this.socketClient = null
        }
    }

    startLogcat() {
        log.debug("Starting logcat capture for testbundle")
        let logcat_args = ["logcat", "-v", "time", "-s", "BOYAA-TESTBUNDLE"]
        let executablePath = this.adb.executable.defaultArgs.join(' ')
        this.logcat_proc_for_testbundle = spawn(executablePath, logcat_args)
        this.logcat_proc_for_testbundle.stdout.setEncoding('utf8')
        this.logcat_proc_for_testbundle.stderr.setEncoding('utf8')

        this.logcat_proc_for_testbundle.on('error', function (err) {
            log.error('Logcat capture failed: ' + err.message);
            if (!this.calledBack) {
                this.calledBack = true;
                cb(err);
            }
        }.bind(this));
        this.logcat_proc_for_testbundle.on('exit', function (code, signal) {
            log.debug('Logcat for testbundle terminated with code ' + code + ', signal ' + signal);
            this.logcat_proc_for_testbundle = null;
        }.bind(this));
        log.debug("Redirecting logcat logs into console to make it received by appium server");
    }

    async shutdown() {
        log.debug('shutting down testbundle ...')
        if (!this.uiAutomator2) {
            log.warn("Cannot shut down Android testbundle; it has already shut down");
            return;
        }
        this.uiAutomator2.removeAllListeners(UiAutomator_Test.EVENT_CHANGED);
        if (this.socketClient) {
            await this.sendCommand(COMMAND_TYPES.SHUTDOWN);
        }
        await this.uiAutomator2.shutdown();
        this.uiAutomator2 = null;

        await this.adb.removePortForward(this.systemPort)
        log.debug('shutting down testbundle ...done!')
    }

    async sendAction(action, params = {}) {
        let extra = {action, params};
        return await this.sendCommand(COMMAND_TYPES.ACTION, extra);
    }

    async sendCommand (type, extra = {}) {
        if (!this.socketClient) {
            throw new Error('Socket connection closed unexpectedly');
        }

        let execommand = async () => {
            return await new Promise ((resolve, reject) => {
                let cmd = Object.assign({cmd: type}, extra);
                let cmdJson = `${JSON.stringify(cmd)} \n`;
                log.debug(`Sending command to testbundle: ${_.trunc(cmdJson, 1000).trim()}`);
                try{
                    this.socketClient.write(cmdJson);
                    this.socketClient.setEncoding('utf8');
                } catch(err) {
		    this.socketClient.removeAllListeners('data');
                    this.socketClient.removeAllListeners('timeout');
                    this.socketClient = net.connect(this.systemPort, function() {
                        log.debug('socket reconnected!')
                        return execommand()
                    });
                }
                let streamData = '';
		this.socketClient.setTimeout(1000 * 60 * 2, () => {
                    log.debug('testbundle socket timeout')
		    this.socketClient.removeAllListeners('data');
                    this.socketClient.removeAllListeners('timeout');
                    resolve('')
                })
                this.socketClient.on('data', (data) => {
                    log.debug("Received command result from testbundle:");
                    try {
                        streamData = JSON.parse(streamData + data);
                        log.debug(streamData)
                        // we successfully parsed JSON so we've got all the data,
                        // remove the socket listener and evaluate
                        this.socketClient.removeAllListeners('data');
                        if (streamData.status === 0) {
                            resolve(streamData.value);
                        }
                        reject(errorFromCode(streamData.status));
                    } catch (ign) {
                        log.debug("Stream still not complete, waiting");
                        streamData += data;
                    }
                });
            });


        }

        return await execommand()
    }

    async getConnection() {
        return new B((resolve, reject) => {
            this.socketClient = net.connect(this.webSocket, function () {
                log.debug('testbundle socket reconnected!!!')
                resolve(this.socketClient)
            })
        })
    }

    /*async sendCommand(type, extra = {}) {
     /!*        if (!this.socketClient) {
     log.debug('==========socket closed========')
     throw new Error('Socket connection closed unexpectedly');
     }*!/
     return await new B((resolve, reject) => {
     let cmd = Object.assign({cmd: type}, extra);
     let cmdJson = `${JSON.stringify(cmd)}\n`;
     log.debug(`Sending command to android testbundle: ${_.trunc(cmdJson, 1000).trim()}`);

     let exeFunc = async () => {
     try {

     if (this.socketClient) {
     this.socketClient.write(cmdJson);
     this.socketClient.setEncoding('utf8');
     this.socketClient('data', (data) => {
     try {
     streamData = JSON.parse(streamData + data);
     // we successfully parsed JSON so we've got all the data,
     // remove the socket listener and evaluate
     this.socketClient.removeAllListeners('data');
     if (streamData.status === 0) {
     resolve(streamData.value);
     }
     log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
     reject(errorFromCode(streamData.status));
     } catch (ign) {
     log.debug("Stream still not complete, waiting");
     streamData += data;
     }
     })
     }

     else {
     let client = new net.Socket();
     let streamData = '';
     client.connect(this.webSocket, '127.0.0.1', function() {
     log.debug('testbundle socket reconnected!')
     log.debug('send stream')
     client.write(cmdJson);
     log.debug('send end')
     client.setEncoding('utf8');



     })
     client.removeAllListeners('data');
     client.on('data', (data) => {
     try {
     log.debug("data:" + data.toString())
     streamData = JSON.parse(streamData + data);

     log.debug("streamdata: " + streamData)

     // we successfully parsed JSON so we've got all the data,
     // remove the socket listener and evaluate
     log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
     if (streamData.status === 0) {
     resolve(streamData.value);
     client.removeAllListeners('data');
     client.close()

     }

     reject(errorFromCode(streamData.status));
     } catch (ign) {
     log.debug("Stream still not complete, waiting");
     streamData += data;
     }
     })
     }


     /!*                    this.socketClient.write(cmdJson);
     this.socketClient.setEncoding('utf8');
     let streamData = '';
     this.socketClient.on('data', (data) => {
     try {
     streamData = JSON.parse(streamData + data);
     // we successfully parsed JSON so we've got all the data,
     // remove the socket listener and evaluate
     this.socketClient.removeAllListeners('data');
     if (streamData.status === 0) {
     resolve(streamData.value);
     }
     log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
     reject(errorFromCode(streamData.status));
     } catch (ign) {
     log.debug("Stream still not complete, waiting");
     streamData += data;
     }
     })*!/

     } catch (e) {
     throw new Error('Error sending command to testbundle' + e)
     }
     }
     //retry(2, exeFunc);
     exeFunc()

     /!*this.socketClient.write(cmdJson);
     this.socketClient.setEncoding('utf8');
     let streamData = '';
     this.socketClient.on('data', (data) => {
     try {
     streamData = JSON.parse(streamData + data);
     // we successfully parsed JSON so we've got all the data,
     // remove the socket listener and evaluate
     this.socketClient.removeAllListeners('data');
     if (streamData.status === 0) {
     resolve(streamData.value);
     }
     log.debug("Received command result from testbundle:" + JSON.stringify(streamData));
     reject(errorFromCode(streamData.status));
     } catch (ign) {
     log.debug("Stream still not complete, waiting");
     streamData += data;
     }
     })*!/

     })

     }*/
}

export default TestBundle
