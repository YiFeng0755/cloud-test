require('source-map-support').install();

/* global describe:true, it:true */
'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

require('mochawait');

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _chaiAsPromised = require('chai-as-promised');

var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);

var _libAsyncbox = require('../lib/asyncbox');

var regIt = it;

_chai2['default'].use(_chaiAsPromised2['default']);
var should = _chai2['default'].should();

describe('sleep', function () {
  it('should work like setTimeout', function callee$1$0() {
    var now;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          now = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(20));

        case 3:
          (Date.now() - now).should.be.above(19);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});

describe('retry', function () {
  var okFnCalls = 0;
  var okFn = function okFn(val1, val2) {
    return _regeneratorRuntime.async(function okFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          okFnCalls++;
          return context$2$0.abrupt('return', val1 * val2);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badFnCalls = 0;
  var badFn = function badFn() {
    return _regeneratorRuntime.async(function badFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          badFnCalls++;
          throw new Error("bad");

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var eventuallyOkFnCalls = 0;
  var eventuallyOkFn = function eventuallyOkFn(times) {
    return _regeneratorRuntime.async(function eventuallyOkFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          eventuallyOkFnCalls++;

          if (!(eventuallyOkFnCalls < times)) {
            context$2$0.next = 5;
            break;
          }

          throw new Error("not ok yet");

        case 5:
          return context$2$0.abrupt('return', times * times);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var eventuallyOkNoSleepFn = function eventuallyOkNoSleepFn(times) {
    return _regeneratorRuntime.async(function eventuallyOkNoSleepFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          eventuallyOkFnCalls++;

          if (!(eventuallyOkFnCalls < times)) {
            context$2$0.next = 3;
            break;
          }

          throw new Error("not ok yet");

        case 3:
          return context$2$0.abrupt('return', times * times);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  it('should return the result of a passing function', function callee$1$0() {
    var start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, okFn, 5, 4));

        case 3:
          res = context$2$0.sent;

          res.should.equal(20);
          (Date.now() - start).should.be.above(14);
          okFnCalls.should.equal(1);

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should retry a failing function and eventually throw the same err', function callee$1$0() {
    var err, start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = null;
          start = Date.now();
          context$2$0.prev = 2;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, badFn));

        case 5:
          context$2$0.next = 10;
          break;

        case 7:
          context$2$0.prev = 7;
          context$2$0.t0 = context$2$0['catch'](2);

          err = context$2$0.t0;

        case 10:
          should.exist(err);
          err.message.should.equal('bad');
          badFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(44);

        case 14:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[2, 7]]);
  });
  it('should return the correct value with a function that eventually passes', function callee$1$0() {
    var err, start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = null;
          start = Date.now();
          context$2$0.prev = 2;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, eventuallyOkFn, 4));

        case 5:
          context$2$0.next = 10;
          break;

        case 7:
          context$2$0.prev = 7;
          context$2$0.t0 = context$2$0['catch'](2);

          err = context$2$0.t0;

        case 10:
          should.exist(err);
          err.message.should.equal('not ok yet');
          eventuallyOkFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(35);

          // rerun with ok number of calls
          start = Date.now();
          eventuallyOkFnCalls = 0;
          context$2$0.next = 18;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, eventuallyOkFn, 3));

        case 18:
          res = context$2$0.sent;

          eventuallyOkFnCalls.should.equal(3);
          res.should.equal(9);
          (Date.now() - start).should.be.above(35);

        case 22:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[2, 7]]);
  });
  it('in sleep mode, should return the correct value with a function that eventually passes', function callee$1$0() {
    var err, start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          eventuallyOkFnCalls = 0;
          err = null;
          start = Date.now();
          context$2$0.prev = 3;
          context$2$0.next = 6;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retryInterval)(3, 15, eventuallyOkNoSleepFn, 4));

        case 6:
          context$2$0.next = 11;
          break;

        case 8:
          context$2$0.prev = 8;
          context$2$0.t0 = context$2$0['catch'](3);

          err = context$2$0.t0;

        case 11:
          should.exist(err);
          err.message.should.equal('not ok yet');
          eventuallyOkFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(30);

          // rerun with ok number of calls
          start = Date.now();
          eventuallyOkFnCalls = 0;
          context$2$0.next = 19;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retryInterval)(3, 15, eventuallyOkNoSleepFn, 3));

        case 19:
          res = context$2$0.sent;

          eventuallyOkFnCalls.should.equal(3);
          res.should.equal(9);
          (Date.now() - start).should.be.above(30);

        case 23:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[3, 8]]);
  });
});

describe('nodeifyAll', function () {
  var asyncFn = function asyncFn(val) {
    return _regeneratorRuntime.async(function asyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          return context$2$0.abrupt('return', val);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var asyncFn2 = function asyncFn2(val) {
    return _regeneratorRuntime.async(function asyncFn2$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          return context$2$0.abrupt('return', [val, val + val]);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badAsyncFn = function badAsyncFn() {
    return _regeneratorRuntime.async(function badAsyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          throw new Error('boo');

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var cbMap = (0, _libAsyncbox.nodeifyAll)({ asyncFn: asyncFn, asyncFn2: asyncFn2, badAsyncFn: badAsyncFn });
  regIt('should turn async functions into nodey things', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(asyncFn('foo'), function (err, val, val2) {
      should.not.exist(err);
      should.not.exist(val2);
      val.should.equal('foo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should turn async functions into nodey things via nodeifyAll', function (done) {
    var start = Date.now();
    cbMap.asyncFn('foo', function (err, val, val2) {
      should.not.exist(err);
      should.not.exist(val2);
      val.should.equal('foo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should turn async functions into nodey things with mult params', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(asyncFn2('foo'), function (err, val) {
      should.not.exist(err);
      val.should.eql(['foo', 'foofoo']);
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should handle errors correctly', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(badAsyncFn('foo'), function (err, val) {
      should.not.exist(val);
      err.message.should.equal('boo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
});

//describe('nodeifyAll', () => {
//let asyncFn = async (val) => {
//await sleep(15);
//return val;
//};
//let asyncFn2 = async (val) => {
//await sleep(15);
//return [val, val + val];
//};
//let badAsyncFn = async () => {
//await sleep(15);
//throw new Error('boo');
//};
//});

describe('parallel', function () {
  var asyncFn = function asyncFn(val) {
    return _regeneratorRuntime.async(function asyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(50));

        case 2:
          return context$2$0.abrupt('return', val);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badAsyncFn = function badAsyncFn() {
    return _regeneratorRuntime.async(function badAsyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(20));

        case 2:
          throw new Error("boo");

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  it('should perform tasks in parallel and return results', function callee$1$0() {
    var vals, promises, start, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v, res;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          vals = [1, 2, 3];
          promises = [];
          start = Date.now();
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 6;

          for (_iterator = _getIterator(vals); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            v = _step.value;

            promises.push(asyncFn(v));
          }
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](6);
          _didIteratorError = true;
          _iteratorError = context$2$0.t0;

        case 14:
          context$2$0.prev = 14;
          context$2$0.prev = 15;

          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }

        case 17:
          context$2$0.prev = 17;

          if (!_didIteratorError) {
            context$2$0.next = 20;
            break;
          }

          throw _iteratorError;

        case 20:
          return context$2$0.finish(17);

        case 21:
          return context$2$0.finish(14);

        case 22:
          context$2$0.next = 24;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)(promises));

        case 24:
          res = context$2$0.sent;

          (Date.now() - start).should.be.above(49);
          (Date.now() - start).should.be.below(59);
          res.sort().should.eql([1, 2, 3]);

        case 28:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[6, 10, 14, 22], [15,, 17, 21]]);
  });
  it('should error with first response', function callee$1$0() {
    var vals, promises, start, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, v, err, res;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          vals = [1, 2, 3];
          promises = [];
          start = Date.now();
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          context$2$0.prev = 6;

          for (_iterator2 = _getIterator(vals); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            v = _step2.value;

            promises.push(asyncFn(v));
          }
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](6);
          _didIteratorError2 = true;
          _iteratorError2 = context$2$0.t0;

        case 14:
          context$2$0.prev = 14;
          context$2$0.prev = 15;

          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }

        case 17:
          context$2$0.prev = 17;

          if (!_didIteratorError2) {
            context$2$0.next = 20;
            break;
          }

          throw _iteratorError2;

        case 20:
          return context$2$0.finish(17);

        case 21:
          return context$2$0.finish(14);

        case 22:
          promises.push(badAsyncFn());
          err = null;
          res = [];
          context$2$0.prev = 25;
          context$2$0.next = 28;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)(promises));

        case 28:
          res = context$2$0.sent;
          context$2$0.next = 34;
          break;

        case 31:
          context$2$0.prev = 31;
          context$2$0.t1 = context$2$0['catch'](25);

          err = context$2$0.t1;

        case 34:
          (Date.now() - start).should.be.above(19);
          (Date.now() - start).should.be.below(49);
          should.exist(err);
          res.should.eql([]);

        case 38:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[6, 10, 14, 22], [15,, 17, 21], [25, 31]]);
  });
  it('should not allow parallelizing bad types of things', function callee$1$0() {
    var err;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = undefined;
          context$2$0.prev = 1;
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)('foo'));

        case 4:
          context$2$0.next = 9;
          break;

        case 6:
          context$2$0.prev = 6;
          context$2$0.t0 = context$2$0['catch'](1);

          err = context$2$0.t0;

        case 9:
          should.exist(err);
          context$2$0.prev = 10;
          context$2$0.next = 13;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)([1]));

        case 13:
          context$2$0.next = 18;
          break;

        case 15:
          context$2$0.prev = 15;
          context$2$0.t1 = context$2$0['catch'](10);

          err = context$2$0.t1;

        case 18:
          should.exist(err);

        case 19:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[1, 6], [10, 15]]);
  });

  describe('waitForCondition', function () {
    it('should wait and succeed', function callee$2$0() {
      var ref, condFn, duration;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            condFn = function condFn() {
              return Date.now() - ref > 200;
            };

            ref = Date.now();
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap((0, _libAsyncbox.waitForCondition)(condFn, { waitMs: 1000, intervalMs: 10 }));

          case 4:
            duration = Date.now() - ref;

            duration.should.be.above(200);
            duration.should.be.below(250);

          case 7:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should wait and fail', function callee$2$0() {
      var ref, condFn;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            condFn = function condFn() {
              return Date.now() - ref > 200;
            };

            ref = Date.now();
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap((0, _libAsyncbox.waitForCondition)(condFn, { waitMs: 100, intervalMs: 10 }).should.be.rejectedWith(/Condition unmet/));

          case 4:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
  });
});

describe('asyncmap', function () {
  var mapper = function mapper(el) {
    return _regeneratorRuntime.async(function mapper$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(10));

        case 2:
          return context$2$0.abrupt('return', el * 2);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };
  var coll = [1, 2, 3];
  it('should map elements one at a time', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)(coll, mapper, false));

        case 3:
          context$2$0.t0 = [2, 4, 6];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.above(30);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should map elements in parallel', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)(coll, mapper));

        case 3:
          context$2$0.t0 = [2, 4, 6];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(20);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)([], mapper, false));

        case 2:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array in parallel', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)([], mapper));

        case 2:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});

describe('asyncfilter', function () {
  var filter = function filter(el) {
    return _regeneratorRuntime.async(function filter$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(5));

        case 2:
          return context$2$0.abrupt('return', el % 2 === 0);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };
  var coll = [1, 2, 3, 4, 5];
  it('should filter elements one at a time', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)(coll, filter, false));

        case 3:
          context$2$0.t0 = [2, 4];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.above(19);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should filter elements in parallel', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)(coll, filter));

        case 3:
          context$2$0.t0 = [2, 4];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(9);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)([], filter, false));

        case 3:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(9);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array in parallel', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)([], filter));

        case 3:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(9);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvYXN5bmNib3gtc3BlY3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztRQUlPLFdBQVc7O29CQUNELE1BQU07Ozs7OEJBQ0ksa0JBQWtCOzs7OzJCQUVxQixpQkFBaUI7O0FBTG5GLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQzs7QUFPZixrQkFBSyxHQUFHLDZCQUFnQixDQUFDO0FBQ3pCLElBQUksTUFBTSxHQUFHLGtCQUFLLE1BQU0sRUFBRSxDQUFDOztBQUUzQixRQUFRLENBQUMsT0FBTyxFQUFFLFlBQU07QUFDdEIsSUFBRSxDQUFDLDZCQUE2QixFQUFFO1FBQzVCLEdBQUc7Ozs7QUFBSCxhQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTs7MkNBQ2Qsd0JBQU0sRUFBRSxDQUFDOzs7QUFDZixXQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUEsQ0FBRSxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Ozs7OztHQUN4QyxDQUFDLENBQUM7Q0FDSixDQUFDLENBQUM7O0FBRUgsUUFBUSxDQUFDLE9BQU8sRUFBRSxZQUFNO0FBQ3RCLE1BQUksU0FBUyxHQUFHLENBQUMsQ0FBQztBQUNsQixNQUFJLElBQUksR0FBRyxTQUFQLElBQUksQ0FBVSxJQUFJLEVBQUUsSUFBSTs7Ozs7MkNBQ3BCLHdCQUFNLEVBQUUsQ0FBQzs7O0FBQ2YsbUJBQVMsRUFBRSxDQUFDOzhDQUNMLElBQUksR0FBRyxJQUFJOzs7Ozs7O0dBQ25CLENBQUM7QUFDRixNQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDbkIsTUFBSSxLQUFLLEdBQUcsU0FBUixLQUFLOzs7OzsyQ0FDRCx3QkFBTSxFQUFFLENBQUM7OztBQUNmLG9CQUFVLEVBQUUsQ0FBQztnQkFDUCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUM7Ozs7Ozs7R0FDdkIsQ0FBQztBQUNGLE1BQUksbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO0FBQzVCLE1BQUksY0FBYyxHQUFHLFNBQWpCLGNBQWMsQ0FBVSxLQUFLOzs7OzsyQ0FDekIsd0JBQU0sRUFBRSxDQUFDOzs7QUFDZiw2QkFBbUIsRUFBRSxDQUFDOztnQkFDbEIsbUJBQW1CLEdBQUcsS0FBSyxDQUFBOzs7OztnQkFDdkIsSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDOzs7OENBRXhCLEtBQUssR0FBRyxLQUFLOzs7Ozs7O0dBQ3JCLENBQUM7QUFDRixNQUFJLHFCQUFxQixHQUFHLFNBQXhCLHFCQUFxQixDQUFVLEtBQUs7Ozs7QUFDdEMsNkJBQW1CLEVBQUUsQ0FBQzs7Z0JBQ2xCLG1CQUFtQixHQUFHLEtBQUssQ0FBQTs7Ozs7Z0JBQ3ZCLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQzs7OzhDQUV4QixLQUFLLEdBQUcsS0FBSzs7Ozs7OztHQUNyQixDQUFDO0FBQ0YsSUFBRSxDQUFDLGdEQUFnRCxFQUFFO1FBQy9DLEtBQUssRUFDTCxHQUFHOzs7O0FBREgsZUFBSyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7OzJDQUNOLHdCQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7O0FBQWhDLGFBQUc7O0FBQ1AsYUFBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDckIsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekMsbUJBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7Ozs7O0dBQzNCLENBQUMsQ0FBQztBQUNILElBQUUsQ0FBQyxtRUFBbUUsRUFBRTtRQUNsRSxHQUFHLEVBQ0gsS0FBSzs7OztBQURMLGFBQUcsR0FBRyxJQUFJO0FBQ1YsZUFBSyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUU7OzsyQ0FFZCx3QkFBTSxDQUFDLEVBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7O0FBRXJCLGFBQUcsaUJBQUksQ0FBQzs7O0FBRVYsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEIsYUFBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLG9CQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQixXQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUEsQ0FBRSxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQzs7Ozs7OztHQUMxQyxDQUFDLENBQUM7QUFDSCxJQUFFLENBQUMsd0VBQXdFLEVBQUU7UUFDdkUsR0FBRyxFQUNILEtBQUssRUFjTCxHQUFHOzs7O0FBZkgsYUFBRyxHQUFHLElBQUk7QUFDVixlQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTs7OzJDQUVkLHdCQUFNLENBQUMsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBRWpDLGFBQUcsaUJBQUksQ0FBQzs7O0FBRVYsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEIsYUFBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3ZDLDZCQUFtQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7OztBQUd6QyxlQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ25CLDZCQUFtQixHQUFHLENBQUMsQ0FBQzs7MkNBQ1Isd0JBQU0sQ0FBQyxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7OztBQUF2QyxhQUFHOztBQUNQLDZCQUFtQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsYUFBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7R0FDMUMsQ0FBQyxDQUFDO0FBQ0gsSUFBRSxDQUFDLHVGQUF1RixFQUFFO1FBRXRGLEdBQUcsRUFDSCxLQUFLLEVBY0wsR0FBRzs7OztBQWhCUCw2QkFBbUIsR0FBRyxDQUFDLENBQUM7QUFDcEIsYUFBRyxHQUFHLElBQUk7QUFDVixlQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTs7OzJDQUVkLGdDQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUscUJBQXFCLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7Ozs7O0FBRXBELGFBQUcsaUJBQUksQ0FBQzs7O0FBRVYsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEIsYUFBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3ZDLDZCQUFtQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7OztBQUd6QyxlQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ25CLDZCQUFtQixHQUFHLENBQUMsQ0FBQzs7MkNBQ1IsZ0NBQWMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxxQkFBcUIsRUFBRSxDQUFDLENBQUM7OztBQUExRCxhQUFHOztBQUNQLDZCQUFtQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsYUFBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7R0FDMUMsQ0FBQyxDQUFDO0NBQ0osQ0FBQyxDQUFDOztBQUVILFFBQVEsQ0FBQyxZQUFZLEVBQUUsWUFBTTtBQUMzQixNQUFJLE9BQU8sR0FBRyxTQUFWLE9BQU8sQ0FBVSxHQUFHOzs7OzsyQ0FDaEIsd0JBQU0sRUFBRSxDQUFDOzs7OENBQ1IsR0FBRzs7Ozs7OztHQUNYLENBQUM7QUFDRixNQUFJLFFBQVEsR0FBRyxTQUFYLFFBQVEsQ0FBVSxHQUFHOzs7OzsyQ0FDakIsd0JBQU0sRUFBRSxDQUFDOzs7OENBQ1IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQzs7Ozs7OztHQUN4QixDQUFDO0FBQ0YsTUFBSSxVQUFVLEdBQUcsU0FBYixVQUFVOzs7OzsyQ0FDTix3QkFBTSxFQUFFLENBQUM7OztnQkFDVCxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUM7Ozs7Ozs7R0FDdkIsQ0FBQztBQUNGLE1BQUksS0FBSyxHQUFHLDZCQUFXLEVBQUMsT0FBTyxFQUFQLE9BQU8sRUFBRSxRQUFRLEVBQVIsUUFBUSxFQUFFLFVBQVUsRUFBVixVQUFVLEVBQUMsQ0FBQyxDQUFDO0FBQ3hELE9BQUssQ0FBQywrQ0FBK0MsRUFBRSxVQUFBLElBQUksRUFBSTtBQUM3RCxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDdkIsOEJBQVEsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLFVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUs7QUFDMUMsWUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdEIsWUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdkIsU0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIsT0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekMsVUFBSSxFQUFFLENBQUM7S0FDUixDQUFDLENBQUM7R0FDSixDQUFDLENBQUM7QUFDSCxPQUFLLENBQUMsOERBQThELEVBQUUsVUFBQSxJQUFJLEVBQUk7QUFDNUUsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFNBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUs7QUFDdkMsWUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdEIsWUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdkIsU0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEIsT0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekMsVUFBSSxFQUFFLENBQUM7S0FDUixDQUFDLENBQUM7R0FDSixDQUFDLENBQUM7QUFDSCxPQUFLLENBQUMsZ0VBQWdFLEVBQUUsVUFBQSxJQUFJLEVBQUk7QUFDOUUsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLDhCQUFRLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxVQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUs7QUFDckMsWUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdEIsU0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMs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QUM7OzsyQkFBYSxFQUFFOzJCQUFiLE1BQU0sQ0FBQyxHQUFHOztBQUNqRCxXQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUEsQ0FBRSxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7OztHQUN6QyxDQUFDLENBQUM7QUFDSCxJQUFFLENBQUMsMENBQTBDLEVBQUU7UUFDekMsS0FBSzs7OztBQUFMLGVBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFOzsyQ0FDZiw4QkFBWSxFQUFFLEVBQUUsTUFBTSxDQUFDOzs7MkJBQWEsRUFBRTsyQkFBYixNQUFNLENBQUMsR0FBRzs7QUFDMUMsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7Ozs7R0FDekMsQ0FBQyxDQUFDO0NBQ0osQ0FBQyxDQUFDIiwiZmlsZSI6InRlc3QvYXN5bmNib3gtc3BlY3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0cmFuc3BpbGU6bW9jaGFcblxuLyogZ2xvYmFsIGRlc2NyaWJlOnRydWUsIGl0OnRydWUgKi9cbmxldCByZWdJdCA9IGl0O1xuaW1wb3J0ICdtb2NoYXdhaXQnO1xuaW1wb3J0IGNoYWkgZnJvbSAnY2hhaSc7XG5pbXBvcnQgY2hhaUFzUHJvbWlzZWQgZnJvbSAnY2hhaS1hcy1wcm9taXNlZCc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwsIG5vZGVpZnksIG5vZGVpZnlBbGwsXG4gICAgICAgICBwYXJhbGxlbCwgYXN5bmNtYXAsIGFzeW5jZmlsdGVyLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnLi4vbGliL2FzeW5jYm94JztcblxuY2hhaS51c2UoY2hhaUFzUHJvbWlzZWQpO1xubGV0IHNob3VsZCA9IGNoYWkuc2hvdWxkKCk7XG5cbmRlc2NyaWJlKCdzbGVlcCcsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCB3b3JrIGxpa2Ugc2V0VGltZW91dCcsIGFzeW5jICgpID0+IHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBhd2FpdCBzbGVlcCgyMCk7XG4gICAgKERhdGUubm93KCkgLSBub3cpLnNob3VsZC5iZS5hYm92ZSgxOSk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdyZXRyeScsICgpID0+IHtcbiAgbGV0IG9rRm5DYWxscyA9IDA7XG4gIGxldCBva0ZuID0gYXN5bmMgKHZhbDEsIHZhbDIpID0+IHtcbiAgICBhd2FpdCBzbGVlcCgxNSk7XG4gICAgb2tGbkNhbGxzKys7XG4gICAgcmV0dXJuIHZhbDEgKiB2YWwyO1xuICB9O1xuICBsZXQgYmFkRm5DYWxscyA9IDA7XG4gIGxldCBiYWRGbiA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBzbGVlcCgxNSk7XG4gICAgYmFkRm5DYWxscysrO1xuICAgIHRocm93IG5ldyBFcnJvcihcImJhZFwiKTtcbiAgfTtcbiAgbGV0IGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPSAwO1xuICBsZXQgZXZlbnR1YWxseU9rRm4gPSBhc3luYyAodGltZXMpID0+IHtcbiAgICBhd2FpdCBzbGVlcCgxNSk7XG4gICAgZXZlbnR1YWxseU9rRm5DYWxscysrO1xuICAgIGlmIChldmVudHVhbGx5T2tGbkNhbGxzIDwgdGltZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBvayB5ZXRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aW1lcyAqIHRpbWVzO1xuICB9O1xuICBsZXQgZXZlbnR1YWxseU9rTm9TbGVlcEZuID0gYXN5bmMgKHRpbWVzKSA9PiB7XG4gICAgZXZlbnR1YWxseU9rRm5DYWxscysrO1xuICAgIGlmIChldmVudHVhbGx5T2tGbkNhbGxzIDwgdGltZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBvayB5ZXRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aW1lcyAqIHRpbWVzO1xuICB9O1xuICBpdCgnc2hvdWxkIHJldHVybiB0aGUgcmVzdWx0IG9mIGEgcGFzc2luZyBmdW5jdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCByZXMgPSBhd2FpdCByZXRyeSgzLCBva0ZuLCA1LCA0KTtcbiAgICByZXMuc2hvdWxkLmVxdWFsKDIwKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgIG9rRm5DYWxscy5zaG91bGQuZXF1YWwoMSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIHJldHJ5IGEgZmFpbGluZyBmdW5jdGlvbiBhbmQgZXZlbnR1YWxseSB0aHJvdyB0aGUgc2FtZSBlcnInLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmV0cnkoMywgYmFkRm4pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcXVhbCgnYmFkJyk7XG4gICAgYmFkRm5DYWxscy5zaG91bGQuZXF1YWwoMyk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDQ0KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIHdpdGggYSBmdW5jdGlvbiB0aGF0IGV2ZW50dWFsbHkgcGFzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJldHJ5KDMsIGV2ZW50dWFsbHlPa0ZuLCA0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICBzaG91bGQuZXhpc3QoZXJyKTtcbiAgICBlcnIubWVzc2FnZS5zaG91bGQuZXF1YWwoJ25vdCBvayB5ZXQnKTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzLnNob3VsZC5lcXVhbCgzKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMzUpO1xuXG4gICAgLy8gcmVydW4gd2l0aCBvayBudW1iZXIgb2YgY2FsbHNcbiAgICBzdGFydCA9IERhdGUubm93KCk7XG4gICAgZXZlbnR1YWxseU9rRm5DYWxscyA9IDA7XG4gICAgbGV0IHJlcyA9IGF3YWl0IHJldHJ5KDMsIGV2ZW50dWFsbHlPa0ZuLCAzKTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzLnNob3VsZC5lcXVhbCgzKTtcbiAgICByZXMuc2hvdWxkLmVxdWFsKDkpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgzNSk7XG4gIH0pO1xuICBpdCgnaW4gc2xlZXAgbW9kZSwgc2hvdWxkIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZSB3aXRoIGEgZnVuY3Rpb24gdGhhdCBldmVudHVhbGx5IHBhc3NlcycsIGFzeW5jICgpID0+IHtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzID0gMDtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZXRyeUludGVydmFsKDMsIDE1LCBldmVudHVhbGx5T2tOb1NsZWVwRm4sIDQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcXVhbCgnbm90IG9rIHlldCcpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgzMCk7XG5cbiAgICAvLyByZXJ1biB3aXRoIG9rIG51bWJlciBvZiBjYWxsc1xuICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzID0gMDtcbiAgICBsZXQgcmVzID0gYXdhaXQgcmV0cnlJbnRlcnZhbCgzLCAxNSwgZXZlbnR1YWxseU9rTm9TbGVlcEZuLCAzKTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzLnNob3VsZC5lcXVhbCgzKTtcbiAgICByZXMuc2hvdWxkLmVxdWFsKDkpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgzMCk7XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdub2RlaWZ5QWxsJywgKCkgPT4ge1xuICBsZXQgYXN5bmNGbiA9IGFzeW5jICh2YWwpID0+IHtcbiAgICBhd2FpdCBzbGVlcCgxNSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgbGV0IGFzeW5jRm4yID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsICsgdmFsXTtcbiAgfTtcbiAgbGV0IGJhZEFzeW5jRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoMTUpO1xuICAgIHRocm93IG5ldyBFcnJvcignYm9vJyk7XG4gIH07XG4gIGxldCBjYk1hcCA9IG5vZGVpZnlBbGwoe2FzeW5jRm4sIGFzeW5jRm4yLCBiYWRBc3luY0ZufSk7XG4gIHJlZ0l0KCdzaG91bGQgdHVybiBhc3luYyBmdW5jdGlvbnMgaW50byBub2RleSB0aGluZ3MnLCBkb25lID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIG5vZGVpZnkoYXN5bmNGbignZm9vJyksIChlcnIsIHZhbCwgdmFsMikgPT4ge1xuICAgICAgc2hvdWxkLm5vdC5leGlzdChlcnIpO1xuICAgICAgc2hvdWxkLm5vdC5leGlzdCh2YWwyKTtcbiAgICAgIHZhbC5zaG91bGQuZXF1YWwoJ2ZvbycpO1xuICAgICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE0KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlZ0l0KCdzaG91bGQgdHVybiBhc3luYyBmdW5jdGlvbnMgaW50byBub2RleSB0aGluZ3MgdmlhIG5vZGVpZnlBbGwnLCBkb25lID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGNiTWFwLmFzeW5jRm4oJ2ZvbycsIChlcnIsIHZhbCwgdmFsMikgPT4ge1xuICAgICAgc2hvdWxkLm5vdC5leGlzdChlcnIpO1xuICAgICAgc2hvdWxkLm5vdC5leGlzdCh2YWwyKTtcbiAgICAgIHZhbC5zaG91bGQuZXF1YWwoJ2ZvbycpO1xuICAgICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE0KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlZ0l0KCdzaG91bGQgdHVybiBhc3luYyBmdW5jdGlvbnMgaW50byBub2RleSB0aGluZ3Mgd2l0aCBtdWx0IHBhcmFtcycsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbm9kZWlmeShhc3luY0ZuMignZm9vJyksIChlcnIsIHZhbCkgPT4ge1xuICAgICAgc2hvdWxkLm5vdC5leGlzdChlcnIpO1xuICAgICAgdmFsLnNob3VsZC5lcWwoWydmb28nLCAnZm9vZm9vJ10pO1xuICAgICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE0KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlZ0l0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBjb3JyZWN0bHknLCBkb25lID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIG5vZGVpZnkoYmFkQXN5bmNGbignZm9vJyksIChlcnIsIHZhbCkgPT4ge1xuICAgICAgc2hvdWxkLm5vdC5leGlzdCh2YWwpO1xuICAgICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKCdib28nKTtcbiAgICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgxNCk7XG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vZGVzY3JpYmUoJ25vZGVpZnlBbGwnLCAoKSA9PiB7XG4gIC8vbGV0IGFzeW5jRm4gPSBhc3luYyAodmFsKSA9PiB7XG4gICAgLy9hd2FpdCBzbGVlcCgxNSk7XG4gICAgLy9yZXR1cm4gdmFsO1xuICAvL307XG4gIC8vbGV0IGFzeW5jRm4yID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgIC8vYXdhaXQgc2xlZXAoMTUpO1xuICAgIC8vcmV0dXJuIFt2YWwsIHZhbCArIHZhbF07XG4gIC8vfTtcbiAgLy9sZXQgYmFkQXN5bmNGbiA9IGFzeW5jICgpID0+IHtcbiAgICAvL2F3YWl0IHNsZWVwKDE1KTtcbiAgICAvL3Rocm93IG5ldyBFcnJvcignYm9vJyk7XG4gIC8vfTtcbi8vfSk7XG5cbmRlc2NyaWJlKCdwYXJhbGxlbCcsICgpID0+IHtcbiAgbGV0IGFzeW5jRm4gPSBhc3luYyAodmFsKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoNTApO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIGxldCBiYWRBc3luY0ZuID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDIwKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJib29cIik7XG4gIH07XG4gIGl0KCdzaG91bGQgcGVyZm9ybSB0YXNrcyBpbiBwYXJhbGxlbCBhbmQgcmV0dXJuIHJlc3VsdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHZhbHMgPSBbMSwgMiwgM107XG4gICAgbGV0IHByb21pc2VzID0gW107XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCB2IG9mIHZhbHMpIHtcbiAgICAgIHByb21pc2VzLnB1c2goYXN5bmNGbih2KSk7XG4gICAgfVxuICAgIGxldCByZXMgPSBhd2FpdCBwYXJhbGxlbChwcm9taXNlcyk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDQ5KTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYmVsb3coNTkpO1xuICAgIHJlcy5zb3J0KCkuc2hvdWxkLmVxbChbMSwgMiwgM10pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBlcnJvciB3aXRoIGZpcnN0IHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCB2YWxzID0gWzEsIDIsIDNdO1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgdiBvZiB2YWxzKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKGFzeW5jRm4odikpO1xuICAgIH1cbiAgICBwcm9taXNlcy5wdXNoKGJhZEFzeW5jRm4oKSk7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBhd2FpdCBwYXJhbGxlbChwcm9taXNlcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE5KTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYmVsb3coNDkpO1xuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIHJlcy5zaG91bGQuZXFsKFtdKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgbm90IGFsbG93IHBhcmFsbGVsaXppbmcgYmFkIHR5cGVzIG9mIHRoaW5ncycsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXJyO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwYXJhbGxlbCgnZm9vJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHBhcmFsbGVsKFsxXSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3YWl0Rm9yQ29uZGl0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgd2FpdCBhbmQgc3VjY2VlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCByZWYgPSBEYXRlLm5vdygpO1xuICAgICAgZnVuY3Rpb24gY29uZEZuKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHJlZiA+IDIwMDtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oY29uZEZuLCB7d2FpdE1zOiAxMDAwLCBpbnRlcnZhbE1zOiAxMH0pO1xuICAgICAgbGV0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHJlZjtcbiAgICAgIGR1cmF0aW9uLnNob3VsZC5iZS5hYm92ZSgyMDApO1xuICAgICAgZHVyYXRpb24uc2hvdWxkLmJlLmJlbG93KDI1MCk7XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCB3YWl0IGFuZCBmYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlZiA9IERhdGUubm93KCk7XG4gICAgICBmdW5jdGlvbiBjb25kRm4oKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gcmVmID4gMjAwO1xuICAgICAgfVxuICAgICAgYXdhaXQgKHdhaXRGb3JDb25kaXRpb24oY29uZEZuLCB7d2FpdE1zOiAxMDAsIGludGVydmFsTXM6IDEwfSkpXG4gICAgICAgIC5zaG91bGQuYmUucmVqZWN0ZWRXaXRoKC9Db25kaXRpb24gdW5tZXQvKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2FzeW5jbWFwJywgKCkgPT4ge1xuICBjb25zdCBtYXBwZXIgPSBhc3luYyBmdW5jdGlvbiAoZWwpIHtcbiAgICBhd2FpdCBzbGVlcCgxMCk7XG4gICAgcmV0dXJuIGVsICogMjtcbiAgfTtcbiAgY29uc3QgY29sbCA9IFsxLCAyLCAzXTtcbiAgaXQoJ3Nob3VsZCBtYXAgZWxlbWVudHMgb25lIGF0IGEgdGltZScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIChhd2FpdCBhc3luY21hcChjb2xsLCBtYXBwZXIsIGZhbHNlKSkuc2hvdWxkLmVxbChbMiwgNCwgNl0pO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgzMCk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIG1hcCBlbGVtZW50cyBpbiBwYXJhbGxlbCcsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIChhd2FpdCBhc3luY21hcChjb2xsLCBtYXBwZXIpKS5zaG91bGQuZXFsKFsyLCA0LCA2XSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmJlbG93KDIwKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIGFuIGVtcHR5IGFycmF5JywgYXN5bmMgKCkgPT4ge1xuICAgIChhd2FpdCBhc3luY21hcChbXSwgbWFwcGVyLCBmYWxzZSkpLnNob3VsZC5lcWwoW10pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgYW4gZW1wdHkgYXJyYXkgaW4gcGFyYWxsZWwnLCBhc3luYyAoKSA9PiB7XG4gICAgKGF3YWl0IGFzeW5jbWFwKFtdLCBtYXBwZXIpKS5zaG91bGQuZXFsKFtdKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2FzeW5jZmlsdGVyJywgKCkgPT4ge1xuICBjb25zdCBmaWx0ZXIgPSBhc3luYyBmdW5jdGlvbiAoZWwpIHtcbiAgICBhd2FpdCBzbGVlcCg1KTtcbiAgICByZXR1cm4gZWwgJSAyID09PSAwO1xuICB9O1xuICBjb25zdCBjb2xsID0gWzEsIDIsIDMsIDQsIDVdO1xuICBpdCgnc2hvdWxkIGZpbHRlciBlbGVtZW50cyBvbmUgYXQgYSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgKGF3YWl0IGFzeW5jZmlsdGVyKGNvbGwsIGZpbHRlciwgZmFsc2UpKS5zaG91bGQuZXFsKFsyLCA0XSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE5KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgZmlsdGVyIGVsZW1lbnRzIGluIHBhcmFsbGVsJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgKGF3YWl0IGFzeW5jZmlsdGVyKGNvbGwsIGZpbHRlcikpLnNob3VsZC5lcWwoWzIsIDRdKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYmVsb3coOSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGhhbmRsZSBhbiBlbXB0eSBhcnJheScsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIChhd2FpdCBhc3luY2ZpbHRlcihbXSwgZmlsdGVyLCBmYWxzZSkpLnNob3VsZC5lcWwoW10pO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg5KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIGFuIGVtcHR5IGFycmF5IGluIHBhcmFsbGVsJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgKGF3YWl0IGFzeW5jZmlsdGVyKFtdLCBmaWx0ZXIpKS5zaG91bGQuZXFsKFtdKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYmVsb3coOSk7XG4gIH0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uIn0=
